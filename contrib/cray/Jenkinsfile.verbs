// Copyright (c) 2018. Cray Inc. All rights reserved.
// (C) Copyright 2020-2023 Hewlett Packard Enterprise Development LP
// Libfabric Verbs provider Jenkins Pipeline file

@Library(['CrayNetworkCI@master', 'dst-shared@master']) _

if (!isBuildable()) {
    echo "build request is not valid, skipping build"
    currentBuild.result = 'SUCCESS'
    return
}

// Note 1: There is a limit on how complex the pipeline can be before the
// interpreter issues the error: Method Code Too Large.  See
// https://support.cloudbees.com/hc/en-us/articles/360039361371-Method-Code-Too-Large-Error
//
// The solution is to move the code normally found in the 'steps' and 'post'
// directives into their own functions.  This has been done for all of the
// stages where possible.
//
// Note 2: The tests are now launched in parallel.  The concurrency
// substantially reduces the wall-time to complete the pipeline *only*
// if the tests don't compete for resources (in particular: specific
// hardware) or compete with other non-Jenkins jobs. YMMV.
//
// Note 3: Debugging the parallel sections is 'not easy'.  Fortunately,
// you can trivial change the pipeline to serial mode by commenting out
//     parallel {
// and inserting
//     stages {
// in its place.  You may need to increase some of the timeouts too.
//
// Note 4: The Slurm partitions on Wham overlap so that jobs which can
// run on any hardware may delay jobs with specific needs (GPU's) resulting
// in serialization and longer pipeline times.  The current scheme is good,
// not entirely predictable, and does not claim to be optimal.
//
// Note 5: The pipeline reserves Slurm nodes and installs a kernel module
// on each.  The Slurm launch commands (srun and sbatch) use the environment
// variable SLURM_RESERVATION to access the correct nodes.  The execution
// environment acquires this variable from Jenkins (using a variable of the
// same name). This is somewhat magical, and is fragile.  Don't change the
// name of the Jenkins variable!

pipeline {
    options {
        // We skip the default checkout from git so that we can
        // wrap it in a retry() block to improve reliability.
        skipDefaultCheckout(true)

        // Generic build options
        buildDiscarder(logRotator(numToKeepStr: '15'))

        // We need a timeout so that jobs don't hang forever, but
        // long enough so that adding stages doesn't put us over.
        timeout(time: 240, unit: 'MINUTES')

        // Build options
        disableConcurrentBuilds()
        timestamps()
        skipStagesAfterUnstable()
        parallelsAlwaysFailFast()
    }
    agent {
        node {
            label 'wham'
        }
    }
    environment {
        ROOT_BUILD_PATH = "/scratch/jenkins/builds"
        FABTEST_PATH = "${WORKSPACE + '/installs/fabtests'}"
        FABTEST_EXCLUDES = "-f contrib/cray/verbs_ofi_rxm.exclude"
        LIBFABRIC_BUILD_PATH = "${ROOT_BUILD_PATH + '/libfabric'}"
        OMB_BUILD_PATH = "${ROOT_BUILD_PATH + '/osu-micro-benchmarks/stable/libexec/osu-micro-benchmarks/mpi'}"
        IMB_BUILD_PATH = "${ROOT_BUILD_PATH + '/imb/v2019.6'}"
        MPICH_PATH = "${ROOT_BUILD_PATH + '/mpich/stable'}"
        SFT_INSTALL_PATH = "${ROOT_BUILD_PATH + '/libfabric-sft/stable'}"
        SFT_PR_ENV_VAR = 'SFT_PR=0'
        BATS_INSTALL_PATH = "${ROOT_BUILD_PATH + '/bats/stable/bin'}"
        CUDA_INSTALL_PATH = "/scratch/opt/cuda"
        ROCR_INSTALL_PATH = "/opt/rocm"
        PMI_INCLUDE_PATH = "/usr/include/slurm"
        PMI_INSTALL_PATH = "/usr/lib64"
        LTU_VERSION = "0.0.0"
        SFT_VERSION = "0.0.0"
        KDREG2_REPO_NAME = 'hpc-shs-kdreg2'
        KDREG2_GIT_REPO = "https://github.hpe.com/hpe/${KDREG2_REPO_NAME}.git"
        KDREG2_BRANCH = 'main'
        LTU_GIT_REPO = 'https://github.hpe.com/hpe/hpc-shs-libfabric-test-utils.git'
        LTU_BRANCH = 'master'
        SFT_GIT_REPO = 'https://github.hpe.com/hpe/hpc-shs-libfabric-sft.git'
        SFT_BRANCH = 'master'
        HPE_GITHUB_TOKEN = 'ghe_jenkins_token'
        CRAY_BIN = 'contrib/cray/bin'
        SLURM_TOTAL_NODES = 10
        SLURM_RESERVATION_SPEC = """nodecnt=${SLURM_TOTAL_NODES} \\
                                    'features=[amd_gpu*2&nvidia_gpu*2&mellanox*6]' \\
                                    'flags=NO_HOLD_JOBS_AFTER,IGNORE_JOBS' \\
                                    duration=2:00:00 \
                                    starttime=now"""
    }
    stages {
        stage('Clean Workspace') {
            steps {
                retry(3) {        // file system on wham is flakey,
                    cleanWs()     // try multiple times
                }
            }
        }
        stage('Clone Libfabric Repo') {
            steps {
                retry(3) {        // connection to repo is somewhat flakey,
                    checkout scm  // try multiple times
                }
            }
        }
        stage('Clone Kdreg2 Repo') {
            steps {
                clone_kdreg2()
            }
        }
        stage('Setup Build Environment') {
            steps {
                setup_build_environment()
            }
        }
        stage('Build CUDA and ROCR') {
            options {
                timeout(time: 10, unit: 'MINUTES')
            }
            environment {
                LD_LIBRARY_PATH = "$ROCR_INSTALL_PATH/lib:$CUDA_INSTALL_PATH/lib64:$LD_LIBRARY_PATH"
            }
            steps {
                build_cuda_and_rocr()
            }
        }
        stage('Verify CUDA and ROCR Build') {
            steps {
                verify_cuda_and_rocr()
            }
            post {
                success {
                    sh "echo CUDA and ROCR build verified"
                }
                failure {
                    sh "echo CUDA and ROCR build did not verify"
                }
            }
        }
        stage('Clean Build Environment') {
            options {
                timeout(time: 5, unit: 'MINUTES')
            }
            steps {
                clean_build_environment()
            }
        }
        stage('Build CUDA and ROCR dlopen') {
            options {
                timeout(time: 10, unit: 'MINUTES')
            }
            steps {
                build_cuda_and_rocr_dlopen()
            }
        }
        stage('Verify CUDA and ROCR Build dlopen') {
            steps {
                verify_cuda_and_rocr_dlopen()
            }
            post {
                success {
                    sh "echo CUDA and ROCR dlopen build verified"
                }
                failure {
                    sh "echo CUDA and ROCR dlopen build did not verify"
                }
            }
        }
        stage('Build Tests') {
            options {
                timeout(time: 15, unit: 'MINUTES')
            }
            stages {
                stage('Build LTU') {
                    steps {
                        build_ltu()
                    }
                }
                stage('Build SFT') {
                    steps {
                        build_sft()
                    }
                }
                stage('Build Kdreg2') {
                    steps {
                        build_kdreg2()
                    }
                }
            }
        }
        stage('Setup Test Environment') {
            environment {
                LD_LIBRARY_PATH = "$LIBFABRIC_INSTALL/lib:$LD_LIBRARY_PATH"
                MPIR_CVAR_OFI_USE_PROVIDER = 'verbs;ofi_rxm'
                LIBFABRIC_INSTALL_PATH = "$LIBFABRIC_INSTALL"
                SFT_BIN = "${LIBFABRIC_INSTALL + '/bin'}"
                SFT_MAX_JOB_TIME = '3'
                SFT_NUM_JOBS = '6'
                SFT_PROVIDER = 'verbs;ofi_rxm'
                SFT_BASELINE_DIR = "contrib/cray"
                SFT_BASELINE_RESULTS_FILE = 'sft_test_results_baseline.txt'
                // SFT_PREVIOUS_BASELINE_RESULTS = 'sft_test_results_baseline.txt'  // unused(?)
                SFT_TEST_CMDS = 'sft_test_commands'
                SFT_TEST_RESULTS = '_test_results.xml'
                SFT_TEST_RESULTS_EXPECTED = 'expected_'
                SFT_TEST_RESULTS_PREFIX = 'BUILD_'
                SFT_TEST_RESULTS_CI = 'sft_ci_results.yaml'
                FI_VERBS_MIN_RNR_TIMER= '4'
                // FI_MR_CACHE_MONITOR = 'disabled'
                FI_MR_CACHE_MONITOR = 'kdreg2'
            }
            stages {
                stage('Reserve Slurm nodes') {
                    steps {
                        reserve_slurm_nodes()
                    }
                }
		stage('Install Kdreg2') {
                    steps {
                        install_kdreg2()
                    }
                }
                stage('Basic Tests') {
                    options {
                        timeout(time: 20, unit: 'MINUTES')
                    }
                    parallel {
                        stage('Smoke tests') {
                            steps {
                                smoke_tests()
                            }
                            post {
                                always {
                                    smoke_tests_post_always()
                                }
                            }
                        }
                        stage('Functional Tests: RC') {
                            steps {
                                functional_tests()
                            }
                            post {
                                always {
                                    functional_tests_post_always()
                                }
                            }
                        }
                        stage('Functional Tests: XRC') {
                            steps {
                                functional_tests_xrc()
                            }
                            post {
                                always {
                                    functional_tests_xrc_post_always()
                                }
                            }
                        }
                    } // End Parallel Basic Tests
                } // End Basic Tests
                stage('IMB Tests') {
                    options {
                        timeout(time: 30, unit: 'MINUTES')
                    }
                    parallel {
                        stage('Tests: IMB1') {
                            steps {
                                run_bats_test('imb1')
                            }
                        }
                        stage('Tests: IMB2') {
                            steps {
                                run_bats_test('imb2')
                            }
                        }
                        stage('Tests: IMB3') {
                            steps {
                                run_bats_test('imb3')
                            }
                        }
                        stage('Tests: IMB4') {
                            steps {
                                run_bats_test('imb4')
                            }
                        }
                        stage('Tests: IMB5') {
                            steps {
                                run_bats_test('imb5')
                            }
                        }
                    } // End Parallel IMB Tests
                    post {
                        always {
				tests_imb_post_always()
                        }
                    }
                } // End IMB Tests
                stage('OMB Tests') {
                    options {
                        timeout(time: 30, unit: 'MINUTES')
                    }
                    parallel {
                        stage('Tests: OMB1') {
                            steps {
                                run_bats_test('omb1')
                            }
                        }
                        stage('Tests: OMB2') {
                            steps {
                                run_bats_test('omb2')
                            }
                        }
                        stage('Tests: OMB3') {
                            steps {
                                run_bats_test('omb3')
                            }
                        }
                        stage('Tests: OMB4') {
                            steps {
                                run_bats_test('omb4')
                            }
                        }
                    } // End Parallel OMB Tests
                    post {
                        always {
				tests_omb_post_always()
                        }
                    }
                } // End OMB Tests
                stage('SFT Tests') {
                    options {
                        timeout(time: 30, unit: 'MINUTES')
                    }
                    parallel {
                        stage('SFT tests: RC') {
                            environment {
                                SFT_ADD_ARGS = "--additional-args ' '"
                                SFT_TEST_RESULTS_SUBDIR = "sft_test_results/RC"
                                SFT_TEST_RESULTS_DIR = "${env.WORKSPACE}" + "/" + "${env.SFT_TEST_RESULTS_SUBDIR}"
                            }
                            steps {
                                sft_tests_rc()
                            }
                            post {
                                always {
                                    sft_tests_rc_post_always()
                                }
                            }
                        }
                        stage('SFT tests: XRC') {
                            environment {
                                SFT_ADD_ARGS = "--additional-args '--use-xrc'"
                                SFT_TEST_RESULTS_SUBDIR = "sft_test_results/XRC"
                                SFT_TEST_RESULTS_DIR = "${env.WORKSPACE}" + "/" + "${env.SFT_TEST_RESULTS_SUBDIR}"
                            }
                            steps {
                                sft_tests_xrc()
                            }
                            post {
                                always {
                                    sft_tests_xrc_post_always()
                                }
                            }
                        }
                        stage('SFT tests: CUDA XRC') {
                            environment {
                                SFT_ADD_ARGS = "--additional-args '--use-xrc --mr-mode PROV_KEY,ALLOCATED,VIRT_ADDR'"
                                SFT_TEST_RESULTS_SUBDIR = "sft_test_results/XRC_CUDA"
                                SFT_TEST_RESULTS_DIR = "${env.WORKSPACE}" + "/" + "${env.SFT_TEST_RESULTS_SUBDIR}"
                                SFT_PARTITION = "nvidiaV100"
                                SFT_GPU = "NVIDIA"
                                LIMIT_TRANSFER_MODE = "gtg"
                                LD_LIBRARY_PATH = "$CUDA_INSTALL_PATH/lib64:$LD_LIBRARY_PATH"
                            }
                            steps {
                                sft_tests_xrc_cuda()
                            }
                            post {
                                always {
                                    sft_tests_xrc_cuda_post_always()
                                }
                            }
                        }
                        stage('SFT tests: ROCR XRC') {
                            environment {
                                SFT_ADD_ARGS = "--additional-args '--use-xrc --mr-mode PROV_KEY,ALLOCATED,VIRT_ADDR'"
                                SFT_TEST_RESULTS_SUBDIR = "sft_test_results/XRC_ROCR"
                                SFT_TEST_RESULTS_DIR = "${env.WORKSPACE}" + "/" + "${env.SFT_TEST_RESULTS_SUBDIR}"
                                SFT_PARTITION = "amdMi60"
                                SFT_GPU = "AMD"
                                LIMIT_TRANSFER_MODE = "gtg"
                                LD_LIBRARY_PATH = "$ROCR_INSTALL_PATH/lib:$LD_LIBRARY_PATH"
                            }
                            steps {
                                sft_tests_xrc_rocr()
                            }
                            post {
                                always {
                                    sft_tests_xrc_rocr_post_always()
                                }
                            }
                        }
                    } // end parallel SFT Tests
                } // end SFT Tests
            } // stages
            post {
                always {
                    uninstall_kdreg2()
		    release_slurm_nodes()
                }
            }
        } // end stage Setup Test Environment
//        stage('Install Libfabric Build') {
//            when {
//                allOf {
//                    expression { currentBuild.currentResult == 'SUCCESS' } ;
//                }
//            }
//            environment {
//                LIBFABRIC_INSTALL_PATH="${LIBFABRIC_BUILD_PATH + '/' + GIT_DESCRIPTION}"
//            }
//            steps {
//                install_libfabric_build()
//            }
//        }
//        stage('Deploy') {
//            when {
//                allOf {
//                    expression { currentBuild.currentResult == 'SUCCESS' } ;
//                }
//            }
//            options {
//                timeout(time: 15, unit: 'MINUTES')
//            }
//            environment {
//                TAG_DIRECTORY = "${LIBFABRIC_BUILD_PATH + '/tags'}"
//            }
//            parallel {
//                stage('Create nightly link') {
//                    when {
//                        allOf {
//                            expression { isInternalBuild() } ;
//                            expression { env.BRANCH_NAME == 'v1.11.x' }
//                        }
//                    }
//                    steps {
//                        create_nightly_link()
//                    }
//                }
//                stage('Create tagged link') {
//                    when {
//                        allOf {
//                            expression { isInternalBuild() } ;
//                            buildingTag()
//                        }
//                    }
//                    steps {
//                        create_tagged_link()
//                    }
//                }
//                stage('Create upstream link') {
//                    when {
//                        allOf {
//                            expression { isOfiwgBuild() } ;
//                            expression { env.BRANCH_NAME == 'master' }
//                        }
//                    }
//                    steps {
//                        create_upstream_link()
//                    }
//                }
//            }
//        }
    } // End Stages
//    post {
//        changed {
//            pipeline_post_changed()
//        }
//    }
}

// ########################################################################

def create_directory_if_needed(String directory) {
    if (!fileExists(directory)) {
        dir(directory) {
            sh "echo \"Created directory `realpath .`\""
        }
    }
}

def clone_kdreg2() {
    dir('kdreg2') {
        deleteDir()
    }
    dir('kdreg2') {
        git url: "${env.KDREG2_GIT_REPO}", credentialsId: "${env.HPE_GITHUB_TOKEN}", branch: "${env.KDREG2_BRANCH}"
        script {
            env.KDREG2_INCLUDE = sh(script:"realpath ./include", returnStdout: true).trim()
        }
    }
    echo "KDREG2_INCLUDE: ${env.KDREG2_INCLUDE}"
}

def setup_build_environment() {
    // creating git short hash
    script {
        GIT_DESCRIPTION = sh(returnStdout: true, script: "git describe --tags").trim()
        LIBFABRIC_INSTALL = pwd tmp: true
        if (changeRequest()) {
            SFT_PR_ENV_VAR = 'SFT_PR=1'
        }
    }

    dir('contrib/cray/bin') {
        // verify requirements
        sh './verify_requirements.sh'

        // install python environment if necessary
        sh './setup.sh'
    }
}

def build_cuda_and_rocr() {
    sh './autogen.sh'
    sh """./configure \
        --prefix=$LIBFABRIC_INSTALL \
        --with-kdreg2=${env.KDREG2_INCLUDE} \
        --with-cuda=$CUDA_INSTALL_PATH \
        --with-rocr=$ROCR_INSTALL_PATH"""
    sh "make -j 12"
    sh "make install"
    dir('fabtests') {
        sh './autogen.sh'
        sh "./configure --with-libfabric=$LIBFABRIC_INSTALL --prefix=$FABTEST_PATH"
        sh "make -j 12"
        sh "make install"
    }
}

def verify_cuda_and_rocr() {
    script {
        cuda_link_count = sh(returnStdout: true,
                             script: """objdump -a -x $LIBFABRIC_INSTALL/lib/libfabric.so |
                                     grep NEED | grep cuda | wc -l""").trim()
        if (cuda_link_count != "2") {
            error("libfabric failed to link to CUDA")
        }
        rocr_link_count = sh(returnStdout: true,
                             script: """objdump -a -x $LIBFABRIC_INSTALL/lib/libfabric.so |
                                     grep NEED | grep hsa | wc -l""").trim()
        if (rocr_link_count != "1") {
            error("libfabric failed to link to ROCR")
        }
    }
}

def clean_build_environment() {
    dir('fabtests') {
        sh "make uninstall || true"
        sh "make distclean || true"
    }
    sh "make uninstall || true"
    sh "make distclean || true"
}

def build_cuda_and_rocr_dlopen() {
    sh "./autogen.sh"
    sh """./configure \
       --prefix=$LIBFABRIC_INSTALL \
       --with-kdreg2=${env.KDREG2_INCLUDE} \
       --with-cuda=$CUDA_INSTALL_PATH --enable-cuda-dlopen \
       --with-rocr=$ROCR_INSTALL_PATH --enable-rocr-dlopen"""
    sh "make -j 12"
    sh "make install"
    dir('fabtests') {
        sh "./autogen.sh"
        sh "./configure --with-libfabric=$LIBFABRIC_INSTALL --prefix=$FABTEST_PATH"
        sh "make -j 12"
        sh "make install"
    }
}

def verify_cuda_and_rocr_dlopen() {
    script {
        cuda_link_count = sh(returnStdout: true,
                             script: """objdump -a -x $LIBFABRIC_INSTALL/lib/libfabric.so |
                                     grep NEED | grep cuda | wc -l""").trim()
        if (cuda_link_count != "0") {
            error("libfabric failed dynamic linking to CUDA")
        }
        rocr_link_count = sh(returnStdout: true,
                             script: """objdump -a -x $LIBFABRIC_INSTALL/lib/libfabric.so |
                                     grep NEED | grep hsa | wc -l""").trim()
        if (rocr_link_count != "0") {
            error("libfabric failed dynamic linking to ROCR")
        }
    }
}

def build_ltu() {
    dir('libfabric-test-utils') {
        deleteDir()
    }
    dir('libfabric-test-utils') {
        git url: "${env.LTU_GIT_REPO}", credentialsId: "${env.HPE_GITHUB_TOKEN}", branch: "${env.LTU_BRANCH}"
        sh "git remote -v"
        script {
            LTU_VERSION = sh(returnStdout: true, script: "cat .version").trim()
            GIT_SHORT_COMMIT = sh(returnStdout: true, script: "git log -n 1 --pretty=format:'%h'").trim()
            LTU_VERSION = "${LTU_VERSION}" + "_${GIT_SHORT_COMMIT}"
        }
        echo "*** Building libfabric-test-utils, Version: ${LTU_VERSION} ***"
        sh "./autogen.sh"
        sh """./configure --prefix=${LIBFABRIC_INSTALL} --with-libfabric=${LIBFABRIC_INSTALL} \
                          --with-nvidia=${CUDA_INSTALL_PATH} --with-amd=${ROCR_INSTALL_PATH} \
                          --with-pmi=${PMI_INSTALL_PATH} --with-pmi_include=${PMI_INCLUDE_PATH} \
                          --with-ltu-build-string=\"libfabric-test-utils-${LTU_VERSION}\""""
        sh "make -j 10"
        sh "make install"
    }
}

def build_sft() {
    dir('libfabric-sft') {
        deleteDir()
    }
    dir('libfabric-sft') {
        git url: "${env.SFT_GIT_REPO}", credentialsId: "${env.HPE_GITHUB_TOKEN}", branch: "${env.SFT_BRANCH}"
        sh "git remote -v"
        script {
            SFT_VERSION = sh(returnStdout: true, script: "cat .version").trim()
            GIT_SHORT_COMMIT = sh(returnStdout: true, script: "git log -n 1 --pretty=format:'%h'").trim()
            SFT_VERSION = "${SFT_VERSION}" + "_${GIT_SHORT_COMMIT}"
        }
        echo "*** Building libfabric-sft, Version: ${SFT_VERSION} ***"
        sh "./autogen.sh"
        sh """./configure --prefix=${LIBFABRIC_INSTALL} --with-libfabric=${LIBFABRIC_INSTALL} \
                          --with-libltu=${LIBFABRIC_INSTALL} \
                          --with-sft-build-string=\"libfabric-sft-${LTU_VERSION}\""""
        sh "make -j 10"
        sh "make install"
    }
}

def build_kdreg2() {
    dir('kdreg2') {
        sh "make modules"
        script {
            env.KDREG2_MODULE = sh(script:"realpath ./kdreg2.ko", returnStdout: true).trim()
        }
        echo "Kdreg2 module location: ${env.KDREG2_MODULE}"
    }
}

// Test setup and teardown

def reserve_slurm_nodes() {
    echo "Creating Slurm reservation ..."
    script {
        env.SLURM_RESERVATION = "libfabric_ci_" +"${BRANCH_NAME}" + "_" + "${BUILD_ID}"
	echo "xxx = ${env.SLURM_RESERVATION}"
        sh """sudo scontrol create reservation=${SLURM_RESERVATION} \\
              user=${USER},root \\
              ${SLURM_RESERVATION_SPEC}"""
	sh 'scontrol show reservation=${SLURM_RESERVATION}'
    }
    echo "Created Slurm reservation ${SLURM_RESERVATION}."
}

def release_slurm_nodes() {
    echo "Releasing Slurm reservation ${env.SLURM_RESERVATION} ..."
    script {
        sh "sudo scontrol delete reservation=${env.SLURM_RESERVATION} || true"
	sh "scontrol show reservation=${env.SLURM_RESERVATION} || true"
    }
    echo "Slurm reservation released."
}

def install_kdreg2() {
    echo "Installing kdreg2 on reserved nodes ..."
    script {
        sh """sudo srun --reservation=${env.SLURM_RESERVATION} \\
              -N ${env.SLURM_TOTAL_NODES} --ntasks-per-node=1 \\
              ${CRAY_BIN}/install_module.sh ${KDREG2_MODULE}"""
    }
    echo "Kdreg2 installed."
}

def uninstall_kdreg2() {
    echo "Uninstalling kdreg2 on reserved nodes ..."
    script {
        sh """sudo srun --reservation=${env.SLURM_RESERVATION} \\
              -N ${env.SLURM_TOTAL_NODES} --ntasks-per-node=1 \\
              ${CRAY_BIN}/uninstall_module.sh ${KDREG2_MODULE} || true"""
    }
    echo "Kdreg2 uninstalled."
}

// Test Group 1

def smoke_tests() {
    tee('smoketests.tap') {
        sh '${BATS_INSTALL_PATH}/bats -t contrib/cray/bats/smoketests.bats'
    }
}

def smoke_tests_post_always() {
    sh """contrib/cray/bin/parse_logfiles.sh \\
          -r smoketests.tap \\
          -w smoketests.xml \\
          tap simple.smoketests simple || true"""

    step([$class: 'XUnitPublisher',
          thresholds: [[$class: 'FailedThreshold', unstableThreshold: '0']],
          tools: [[$class: 'JUnitType', pattern: "smoketests.xml"]]])
}

def functional_tests() {
    tee('fabtests-rc.log') {
        sh """srun -n 2 --ntasks-per-node=1 \\
              contrib/cray/bin/fabtest_wrapper.sh -p ${FABTEST_PATH}/bin -v -T 120 \\
              ${FABTEST_EXCLUDES}"""
    }
    tee('ubertests-rc.log') {
        sh """srun -n 2 --ntasks-per-node=1 \\
              contrib/cray/bin/fabtest_wrapper.sh -p ${FABTEST_PATH}/bin -vvv -T 120 \\
              ${FABTEST_EXCLUDES} -t complex -u all || true"""
    }
}

def functional_tests_post_always() {
    sh """contrib/cray/bin/parse_logfiles.sh \\
          -r fabtests-rc.log \\
          -w fabtests-rc.xml \\
          fabtests \\
          functional.fabtests.rc.quick \\
          functional || true"""

    sh """contrib/cray/bin/parse_logfiles.sh \\
          -r ubertests-rc.log \\
          -w ubertests-rc.xml \\
          fabtests \\
          functional.fabtests.rc.uber \\
          functional || true"""
}

def functional_tests_xrc() {
    tee('fabtests-xrc.log') {
        sh """srun -n 2 --ntasks-per-node=1 \\
              contrib/cray/bin/fabtest_wrapper.sh -p ${FABTEST_PATH}/bin -v -T 120 \\
              ${FABTEST_EXCLUDES} \\
              -e FI_VERBS_PREFER_XRC=1 \\
              -e FI_OFI_RXM_USE_SRX=1"""
    }
    tee('ubertests-xrc.log') {
        sh """srun -n 2 --ntasks-per-node=1 \\
              contrib/cray/bin/fabtest_wrapper.sh -p ${FABTEST_PATH}/bin -vvv -T 120 \\
              ${FABTEST_EXCLUDES} \\
              -t complex -u all \\
              -e FI_VERBS_PREFER_XRC=1 \\
              -e FI_OFI_RXM_USE_SRX=1"""
    }
}

def functional_tests_xrc_post_always() {
    sh """contrib/cray/bin/parse_logfiles.sh \\
          -r fabtests-xrc.log \\
          -w fabtests-xrc.xml \\
          fabtests \\
          functional.fabtests.xrc.quick \\
          functional || true"""

    sh """contrib/cray/bin/parse_logfiles.sh \\
          -r ubertests-xrc.log \\
          -w ubertests-xrc.xml \\
          fabtests \\
          functional.fabtests.xrc.uber \\
          functional || true"""
}

def run_bats_test(String base) {
    tee(base + ".tap") {
        sh "${BATS_INSTALL_PATH}/bats -t contrib/cray/bats/" + base + ".bats"
    }
}

def tests_imb_post_always() {
    sh """for i in \$(seq 1 5); do \\
              contrib/cray/bin/parse_logfiles.sh \\
              -r imb\$i.tap \\
              -w imb\$i.xml \\
              tap applications.mpi applications || true; \\
          done"""

    step([$class: 'XUnitPublisher',
          thresholds: [[$class: 'FailedThreshold', unstableThreshold: '0']],
          tools: [[$class: 'JUnitType', pattern: "imb*.xml"]]])
}

def tests_omb_post_always() {
    sh """for i in \$(seq 1 4); do \
              contrib/cray/bin/parse_logfiles.sh \\
              -r omb\$i.tap \\
              -w omb\$i.xml \\
              tap applications.mpi applications || true; \\
          done"""

    step([$class: 'XUnitPublisher',
          thresholds: [[$class: 'FailedThreshold', unstableThreshold: '0']],
          tools: [[$class: 'JUnitType', pattern: "omb*.xml"]]])
}

// Test Group 2

def execute_sft_tests(String test_name)
{
    create_directory_if_needed("${SFT_TEST_RESULTS_DIR}")
    script {
        try {
            dir("${SFT_BIN}") {
                sh """${SFT_PR_ENV_VAR} ./ci-all.sh \\
                      --provider '${SFT_PROVIDER}' \\
                      -L ${SFT_TEST_RESULTS_DIR} \\
                      --num-jobs ${SFT_NUM_JOBS} \\
                      --max-job-time ${SFT_MAX_JOB_TIME} \\
                      --output-cmds ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_CMDS} \\
                      --results-file ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_RESULTS_CI} \\
                      ${SFT_ADD_ARGS}"""
            }
        } catch (exc) {
            echo test_name + ' failed, ignore result for now'
        }
    }
}

def sft_tests_post_always() {
    try {
        sh """cp ./${SFT_BASELINE_DIR}/${SFT_BASELINE_RESULTS_FILE} ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE}
              ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_RMA${SFT_TEST_RESULTS} -p "TR_RMA"
              ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_TAGGED${SFT_TEST_RESULTS} -p "TR_TAGGED"
              ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_MESSAGE${SFT_TEST_RESULTS} -p "TR_MESSAGE"
              ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_AMO${SFT_TEST_RESULTS} -p "TR_AMO"
              gzip -r ${SFT_TEST_RESULTS_DIR}
              gunzip ${SFT_TEST_RESULTS_DIR}/sft_*${SFT_TEST_RESULTS}.gz
              gunzip ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE}"""
        // archive the results
        archiveArtifacts artifacts: "${env.SFT_TEST_RESULTS_SUBDIR}/*"

        step([$class: 'XUnitPublisher',
             thresholds: [[$class: 'FailedThreshold', unstableThreshold: '0']],
             tools: [[$class: 'JUnitType', pattern: "*-xrc.xml"]]])
        step([$class: 'XUnitPublisher',
             thresholds: [[$class: 'FailedThreshold', unstableThreshold: '0']],
             tools: [[$class: 'JUnitType', pattern: "${SFT_TEST_RESULTS_SUBDIR}/sft_*_test_results.xml"]]])
    }
    catch (e) {
        echo "Error archiving SFT artifacts: $e"
    }
}

def sft_tests_rc() {
    execute_sft_tests('SFT Tests: RC')
}

def sft_tests_rc_post_always() {
    sft_tests_post_always()
}

def sft_tests_xrc() {
    execute_sft_tests('SFT Tests: XRC')
}

def sft_tests_xrc_post_always() {
    sft_tests_post_always()
}

def sft_tests_xrc_cuda() {
    execute_sft_tests('SFT Tests: XRC CUDA')
}

def sft_tests_xrc_cuda_post_always() {
    sft_tests_post_always()
}

def sft_tests_xrc_rocr() {
    execute_sft_tests('SFT Tests: XRC ROCR')
}

def sft_tests_xrc_rocr_post_always() {
    sft_tests_post_always()
}

def install_libfabric_build() {
    script {
        BUILD_LIBFABRIC = 'false'
        if ( isInternalBuild() &&
            (( env.BRANCH_NAME == 'master' ) || buildingTag())) {
            BUILD_LIBFABRIC = 'true'
        } else if ( isOfiwgBuild() && ( env.BRANCH_NAME == 'master' )) {
            LIBFABRIC_INSTALL_PATH="${LIBFABRIC_BUILD_PATH + '/' + 'OFIWG_' + GIT_DESCRIPTION}"
            BUILD_LIBFABRIC = 'true'
        }
        echo "*** Install Libfabric Build: BUILD_LIBFABRIC: $BUILD_LIBFABRIC ***"
        if ( BUILD_LIBFABRIC == 'true' ) {
            sh "make uninstall || true"
            sh "make distclean || true"
            sh "./autogen.sh"
            sh """./configure \
               --prefix=$LIBFABRIC_INSTALL_PATH \
               --with-kdreg2=${env.KDREG2_INCLUDE} \
               --with-cuda=$CUDA_INSTALL_PATH --enable-cuda-dlopen \
               --with-rocr=$ROCR_INSTALL_PATH --enable-rocr-dlopen"""
            sh "make -j 12"
            sh "make install"
        }
    }
}

def create_nightly_link() {
    dir(env.TAG_DIRECTORY) {
        sh "rm -f nightly || true"
        sh "ln -s ../$GIT_DESCRIPTION nightly"
    }
}

def create_tagged_link() {
    dir(env.TAG_DIRECTORY) {
        sh "rm -f $BRANCH_NAME || true"
        sh "ln -s ../$GIT_DESCRIPTION $BRANCH_NAME"
    }
}

def create_upstream_link() {
    dir(env.TAG_DIRECTORY) {
        sh "rm -f upstream || true"
        sh "ln -s ../OFIWG_$GIT_DESCRIPTION upstream"
    }
}

def pipeline_post_changed() {
    script {
        // send email when the state of the pipeline changes
        // only sends email to @cray.com

        def emailBody = createEmail(build : currentBuild)
        def providers = []
        def defaultMailer = ''

        if (env.BRANCH_NAME == 'master') {
            defaultMailer = mailingList()
        } else {
            providers.add([$class: 'CulpritsRecipientProvider'])
            providers.add([$class: 'RequesterRecipientProvider'])
            providers.add([$class: 'DevelopersRecipientProvider'])
        }
        emailext subject: '$DEFAULT_SUBJECT',
            body: emailBody,
            mimeType: 'text/html',
            recipientProviders: providers,
            replyTo: '$DEFAULT_REPLYTO',
            to: defaultMailer
    }
}
